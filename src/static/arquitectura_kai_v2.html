<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosistema KAI v2 - Arquitectura Multi-Agente</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0b1120;
            --card-bg: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            
            /* Colores de Flujo */
            --flow-user: #3b82f6;   /* Azul */
            --flow-logic: #8b5cf6;  /* Violeta */
            --flow-data: #10b981;   /* Verde */
            --flow-ai: #ef4444;     /* Rojo/Gemini */
            --flow-infra: #f59e0b;  /* Naranja */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        header {
            padding: 20px 40px;
            pointer-events: auto;
            background: linear-gradient(180deg, rgba(11,17,32,0.9) 0%, rgba(11,17,32,0) 100%);
        }

        h1 {
            margin: 0;
            font-weight: 300;
            font-size: 24px;
            letter-spacing: 1px;
        }
        
        h1 span {
            font-weight: 600;
            background: linear-gradient(to right, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(30, 41, 59, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #334155;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        /* Canvas Layer */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Nodes (HTML Elements positioned over canvas) */
        .node-container {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none; /* Let clicks pass to canvas if needed, but we want nodes interactive */
        }

        .node {
            position: absolute;
            background: var(--card-bg);
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 12px;
            width: 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            pointer-events: auto;
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            cursor: default;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
        }

        .node:hover {
            transform: translateY(-5px) scale(1.02);
            z-index: 20;
            border-color: var(--flow-user);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        .node-icon {
            font-size: 24px;
            margin-bottom: 6px;
        }

        .node-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .node-sub {
            font-size: 10px;
            color: var(--text-secondary);
            line-height: 1.2;
        }

        .status-dot {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .status-active { background-color: #10b981; box-shadow: 0 0 8px #10b981; }
        .status-dev { background-color: #f59e0b; }
        .status-plan { background-color: #64748b; border: 1px solid #94a3b8; }

        /* Zone Labels */
        .zone-label {
            position: absolute;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #475569;
            font-weight: 600;
            border-bottom: 1px solid #334155;
            padding-bottom: 5px;
            width: 200px;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <header>
        <h1>KAI v2 <span>ECOSYSTEM</span></h1>
        <div style="font-size: 12px; color: #94a3b8; margin-top: 5px;">LangGraph Orchestration & Google Cloud Native</div>
    </header>

    <div class="legend ui-layer">
        <div class="legend-item"><div class="dot" style="background: #3b82f6;"></div>Usuario / Interacci√≥n</div>
        <div class="legend-item"><div class="dot" style="background: #8b5cf6;"></div>Orquestaci√≥n (LangGraph)</div>
        <div class="legend-item"><div class="dot" style="background: #ef4444;"></div>Inferencia AI (Gemini)</div>
        <div class="legend-item"><div class="dot" style="background: #10b981;"></div>Datos / Herramientas</div>
        <div style="margin-top: 10px; font-size: 10px; border-top: 1px solid #334155; padding-top: 5px;">
            <span style="color: #10b981">‚óè</span> Prod &nbsp; <span style="color: #f59e0b">‚óè</span> Dev &nbsp; <span style="color: #64748b">‚óã</span> Plan
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="network"></canvas>
    </div>

    <!-- Nodos posicionados via JS para responsividad relativa -->
    <div class="node-container" id="node-layer">
        <!-- Labels -->
        <div class="zone-label" style="top: 8%; left: 5%;">Canales de Entrada</div>
        <div class="zone-label" style="top: 8%; left: 35%;">Core & Agentes</div>
        <div class="zone-label" style="top: 8%; left: 75%;">Infraestructura GCP</div>
    </div>

    <script>
        // --- CONFIGURACI√ìN DE NODOS ---
        const nodesConfig = [
            // CANALES (Izquierda)
            { id: 'user_app', x: 0.08, y: 0.30, label: 'Mobile App', sub: 'iOS / Android', icon: 'üì±', type: 'channel' },
            { id: 'user_wa', x: 0.08, y: 0.50, label: 'WhatsApp', sub: 'Twilio/Meta API', icon: 'üí¨', type: 'channel' },
            { id: 'user_web', x: 0.08, y: 0.70, label: 'Web Portal', sub: 'B2B Dashboard', icon: 'üíª', type: 'channel' },

            // GATEWAY & ORCHESTRATOR (Centro-Izquierda)
            { id: 'gateway', x: 0.25, y: 0.50, label: 'API Gateway', sub: 'Cloud Run / FastAPI', icon: 'üõ°Ô∏è', type: 'core', status: 'active' },
            { id: 'orchestrator', x: 0.40, y: 0.50, label: 'Supervisor Graph', sub: 'LangGraph State', icon: 'üß†', type: 'core', status: 'active' },

            // AGENTES (Centro - Enjambre vertical)
            { id: 'agent_vision', x: 0.58, y: 0.15, label: 'Vision Agent', sub: 'Detecci√≥n de Da√±os', icon: 'üëÅÔ∏è', type: 'agent', status: 'dev' },
            { id: 'agent_claims', x: 0.58, y: 0.30, label: 'Claims Agent', sub: 'Auto Insurance Rules', icon: 'üöó', type: 'agent', status: 'active' },
            { id: 'agent_home', x: 0.58, y: 0.45, label: 'Home Agent', sub: 'Asistencia Hogar', icon: 'üè†', type: 'agent', status: 'plan' },
            { id: 'agent_support', x: 0.58, y: 0.60, label: 'Support Agent', sub: 'FAQ & Helpdesk', icon: 'üéß', type: 'agent', status: 'active' },
            { id: 'agent_auditor', x: 0.58, y: 0.75, label: 'Auditor Agent', sub: 'Compliance Review', icon: '‚öñÔ∏è', type: 'agent', status: 'dev' },
            { id: 'agent_bidi', x: 0.58, y: 0.90, label: 'Bidi Voice', sub: 'Real-time Audio', icon: 'üéôÔ∏è', type: 'agent', status: 'plan' },

            // INFRAESTRUCTURA (Derecha)
            { id: 'vertex', x: 0.85, y: 0.30, label: 'Vertex AI', sub: 'Gemini 1.5 Pro/Flash', icon: 'üíé', type: 'infra', status: 'active' },
            { id: 'firestore', x: 0.85, y: 0.50, label: 'Firestore', sub: 'Memory & State', icon: 'üî•', type: 'infra', status: 'active' },
            { id: 'bigquery', x: 0.85, y: 0.70, label: 'BigQuery', sub: 'DWH & Analytics', icon: 'üîç', type: 'infra', status: 'active' },
            { id: 'tools_ext', x: 0.85, y: 0.90, label: 'Ext. Tools', sub: 'Asana / Gmail / SQL', icon: 'üõ†Ô∏è', type: 'infra', status: 'active' },
        ];

        // --- CONFIGURACI√ìN DE CONEXIONES (Grafo L√≥gico) ---
        const connectionsConfig = [
            // Canales a Gateway
            { from: 'user_app', to: 'gateway', type: 'user' },
            { from: 'user_wa', to: 'gateway', type: 'user' },
            { from: 'user_web', to: 'gateway', type: 'user' },

            // Gateway a Orquestador
            { from: 'gateway', to: 'orchestrator', type: 'logic' },

            // Orquestador a Agentes (Delegaci√≥n)
            { from: 'orchestrator', to: 'agent_claims', type: 'logic' },
            { from: 'orchestrator', to: 'agent_vision', type: 'logic' },
            { from: 'orchestrator', to: 'agent_home', type: 'logic' },
            { from: 'orchestrator', to: 'agent_support', type: 'logic' },
            { from: 'orchestrator', to: 'agent_auditor', type: 'logic' },
            { from: 'orchestrator', to: 'agent_bidi', type: 'logic' },

            // Agentes a Infraestructura (Dependencias)
            // Vision usa Vertex y guarda en Storage (simulado en Tools)
            { from: 'agent_vision', to: 'vertex', type: 'ai' }, 
            
            // Claims usa Firestore para estado y Vertex para NLP
            { from: 'agent_claims', to: 'vertex', type: 'ai' },
            { from: 'agent_claims', to: 'firestore', type: 'data' },

            // Support usa Tools (Busqueda) y Vertex
            { from: 'agent_support', to: 'tools_ext', type: 'data' },
            { from: 'agent_support', to: 'vertex', type: 'ai' },

            // Auditor verifica contra BigQuery y usa Vertex
            { from: 'agent_auditor', to: 'bigquery', type: 'data' },
            { from: 'agent_auditor', to: 'vertex', type: 'ai' },

            // Orquestador persiste memoria global
            { from: 'orchestrator', to: 'firestore', type: 'data' },
            
            // Bidi voice directo a Vertex (Audio)
            { from: 'agent_bidi', to: 'vertex', type: 'ai' }
        ];

        const canvas = document.getElementById('network');
        const ctx = canvas.getContext('2d');
        const nodeLayer = document.getElementById('node-layer');
        
        let width, height;
        let nodes = {}; // Map id -> html element & coordinates
        let paths = []; // Array of calculated bezier paths
        let particles = [];

        // --- INICIALIZACI√ìN ---
        function init() {
            createNodes();
            resize();
            window.addEventListener('resize', resize);
            createParticles();
            animate();
        }

        function createNodes() {
            nodesConfig.forEach(conf => {
                const el = document.createElement('div');
                el.className = 'node';
                el.id = conf.id;
                
                // Status dot
                const dot = document.createElement('div');
                dot.className = `status-dot status-${conf.status || 'active'}`;
                el.appendChild(dot);

                const icon = document.createElement('div');
                icon.className = 'node-icon';
                icon.textContent = conf.icon;
                el.appendChild(icon);

                const title = document.createElement('span');
                title.className = 'node-title';
                title.textContent = conf.label;
                el.appendChild(title);

                const sub = document.createElement('span');
                sub.className = 'node-sub';
                sub.textContent = conf.sub;
                el.appendChild(sub);

                nodeLayer.appendChild(el);
                nodes[conf.id] = { el, config: conf };
            });
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            // Actualizar posiciones absolutas de los nodos
            Object.values(nodes).forEach(n => {
                const x = n.config.x * width - 80; // Center offset (width/2)
                const y = n.config.y * height - 40; // Center offset (height/2 approx)
                n.el.style.left = `${x}px`;
                n.el.style.top = `${y}px`;
                
                // Guardar centro real para el canvas
                n.cx = n.config.x * width;
                n.cy = n.config.y * height;
            });

            // Recalcular caminos
            calculatePaths();
        }

        function calculatePaths() {
            paths = [];
            connectionsConfig.forEach(conn => {
                const n1 = nodes[conn.from];
                const n2 = nodes[conn.to];
                if(!n1 || !n2) return;

                // Calcular puntos de control para curva Bezier C√∫bica
                // Hacemos que las curvas salgan horizontalmente
                const cp1x = n1.cx + (n2.cx - n1.cx) * 0.5;
                const cp1y = n1.cy;
                const cp2x = n1.cx + (n2.cx - n1.cx) * 0.5;
                const cp2y = n2.cy;

                paths.push({
                    start: {x: n1.cx, y: n1.cy},
                    end: {x: n2.cx, y: n2.cy},
                    cp1: {x: cp1x, y: cp1y},
                    cp2: {x: cp2x, y: cp2y},
                    type: conn.type
                });
            });
        }

        // --- SISTEMA DE PART√çCULAS (Matem√°ticas Reales) ---
        
        // Funci√≥n de Bezier C√∫bica: B(t) = (1-t)^3 P0 + 3(1-t)^2 t P1 + 3(1-t) t^2 P2 + t^3 P3
        function getBezierPoint(t, p0, p1, p2, p3) {
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;
            const t2 = t * t;
            const t3 = t2 * t;

            const x = mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x;
            const y = mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y;
            return { x, y };
        }

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                // Elegir un camino aleatorio
                this.path = paths[Math.floor(Math.random() * paths.length)];
                this.t = 0;
                // Velocidad variable basada en el tipo de camino
                this.speed = 0.003 + Math.random() * 0.004;
                this.size = 2 + Math.random() * 2;
                
                // Color basado en tipo
                switch(this.path.type) {
                    case 'user': this.color = '#3b82f6'; break;
                    case 'logic': this.color = '#8b5cf6'; break;
                    case 'ai': this.color = '#ef4444'; this.speed *= 1.5; break; // AI m√°s r√°pido
                    case 'data': this.color = '#10b981'; break;
                    default: this.color = '#f1f5f9';
                }
            }

            update() {
                this.t += this.speed;
                if (this.t >= 1) {
                    this.reset();
                }
            }

            draw(ctx) {
                if (!this.path) return;
                
                const pos = getBezierPoint(
                    this.t, 
                    this.path.start, 
                    this.path.cp1, 
                    this.path.cp2, 
                    this.path.end
                );

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                // Glow effect
                ctx.shadowBlur = 8;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset
            }
        }

        function createParticles() {
            // N√∫mero de part√≠culas
            for(let i=0; i<40; i++) {
                particles.push(new Particle());
            }
        }

        function drawNetwork() {
            ctx.clearRect(0, 0, width, height);

            // 1. Dibujar L√≠neas (Fondo)
            ctx.lineWidth = 1;
            paths.forEach(p => {
                ctx.beginPath();
                ctx.moveTo(p.start.x, p.start.y);
                ctx.bezierCurveTo(p.cp1.x, p.cp1.y, p.cp2.x, p.cp2.y, p.end.x, p.end.y);
                
                // Color de l√≠nea tenue seg√∫n tipo
                let stroke = '#334155'; // Default slate-700
                if(p.type === 'ai') stroke = 'rgba(239, 68, 68, 0.2)'; // Red tint for AI
                
                ctx.strokeStyle = stroke;
                ctx.stroke();
            });

            // 2. Dibujar Part√≠culas
            particles.forEach(p => {
                p.update();
                p.draw(ctx);
            });
        }

        function animate() {
            drawNetwork();
            requestAnimationFrame(animate);
        }

        // Start
        init();

    </script>
</body>
</html>